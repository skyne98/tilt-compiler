// ===================================================================
// FILE: tilt.lalrpop
//
// DESC: LALRPOP grammar for the TILT language. This generates a parser
//       that works with our custom lexer tokens.
// ===================================================================

use std::str::FromStr;
use crate::lexer::Token;
use tilt_ast::*;

grammar<'input>;

// Use our custom lexer tokens
extern {
    type Location = usize;
    type Error = ();

    enum Token<'input> {
        // Keywords
        "fn" => Token::Fn,
        "import" => Token::Import,
        "ret" => Token::Ret,
        "br" => Token::Br,
        "br_if" => Token::BrIf,
        "phi" => Token::Phi,
        "call" => Token::Call,

        // Types
        "i32" => Token::TI32,
        "i64" => Token::TI64,
        "f32" => Token::TF32,
        "f64" => Token::TF64,
        "void" => Token::TVoid,

        // Punctuation
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        ":" => Token::Colon,
        "=" => Token::Equals,
        "," => Token::Comma,
        "->" => Token::Arrow,

        // Literals and Identifiers
        "string" => Token::String(<&'input str>),
        "number" => Token::Number(<&'input str>),
        "identifier" => Token::Identifier(<&'input str>),
    }
}

// Type parsing
pub Type: Type = {
    "i32" => Type::I32,
    "i64" => Type::I64,
    "f32" => Type::F32,
    "f64" => Type::F64,
    "void" => Type::Void,
};

// Identifier parsing
pub Identifier: &'input str = {
    "identifier" => <>,
};

// String literal parsing
pub StringLiteral: &'input str = {
    "string" => <>,
};

// Number parsing
pub NumberLiteral: i64 = {
    "number" => i64::from_str(<>).unwrap(),
};

// Typed identifier parsing
pub TypedIdentifier: TypedIdentifier<'input> = {
    <name:Identifier> ":" <ty:Type> => TypedIdentifier { name, ty },
};

// Value parsing
pub Value: Value<'input> = {
    <n:NumberLiteral> => Value::Constant(n as i32),
    <id:Identifier> => Value::Variable(id),
};

// Simple expression parsing - handle function calls and constants
pub Expression: Expression<'input> = {
    // Function calls with parentheses
    "call" <name:Identifier> "(" ")" => Expression::Call { name, args: Vec::new() },
    "call" <name:Identifier> "(" <args:ArgumentList> ")" => Expression::Call { name, args },
    
    // Constant values as direct constants
    <n:NumberLiteral> => Expression::Constant(n as i32),
};

// Simple instruction parsing - assignment and call instructions
pub Instruction: Instruction<'input> = {
    <dest:TypedIdentifier> "=" <expr:Expression> => Instruction::Assign { dest, expr },
    "call" <name:Identifier> "(" ")" => Instruction::Call { name, args: Vec::new() },
    "call" <name:Identifier> "(" <args:ArgumentList> ")" => Instruction::Call { name, args },
};

// Simple terminator parsing
pub Terminator: Terminator<'input> = {
    // Branch
    "br" <label:Identifier> => Terminator::Br { label },
    
    // Conditional branch
    "br_if" <cond:Value> "," <true_label:Identifier> "," <false_label:Identifier> => 
        Terminator::BrIf { cond, true_label, false_label },
        
    // Return with value using parentheses to make it unambiguous
    "ret" "(" <value:Value> ")" => Terminator::Ret(Some(value)),
    
    // Void return
    "ret" => Terminator::Ret(None),
};

// Block parsing
pub Block: Block<'input> = {
    <label:Identifier> ":" <instructions:Instruction*> <terminator:Terminator> => 
        Block { label, instructions, terminator },
};

// Simple import declaration parsing
pub ImportDecl: ImportDecl<'input> = {
    "import" <module:StringLiteral> <name:StringLiteral> "(" <params:ParameterList> ")" "->" <return_type:Type> => 
        ImportDecl {
            module,
            name,
            params,
            return_type,
        },
    "import" <module:StringLiteral> <name:StringLiteral> "->" <return_type:Type> => 
        ImportDecl {
            module,
            name,
            params: Vec::new(),
            return_type,
        },
};

// Simple function definition parsing
pub FunctionDef: FunctionDef<'input> = {
    "fn" <name:Identifier> "(" <params:ParameterList> ")" "->" <return_type:Type> "{" <blocks:Block*> "}" => 
        FunctionDef {
            name,
            params,
            return_type,
            blocks,
        },
    "fn" <name:Identifier> "(" ")" "->" <return_type:Type> "{" <blocks:Block*> "}" => 
        FunctionDef {
            name,
            params: Vec::new(),
            return_type,
            blocks,
        },
};

// Top-level item parsing
pub TopLevelItem: TopLevelItem<'input> = {
    <import:ImportDecl> => TopLevelItem::Import(import),
    <function:FunctionDef> => TopLevelItem::Function(function),
};

// Program parsing (root rule)
pub Program: Program<'input> = {
    <items:TopLevelItem*> => Program { items },
};

// Parameter list for functions and imports
pub ParameterList: Vec<TypedIdentifier<'input>> = {
    <param:TypedIdentifier> => vec![param],
    <mut params:ParameterList> "," <param:TypedIdentifier> => {
        params.push(param);
        params
    },
};

// Argument list for function calls
pub ArgumentList: Vec<Value<'input>> = {
    <arg:Value> => vec![arg],
    <mut args:ArgumentList> "," <arg:Value> => {
        args.push(arg);
        args
    },
};
